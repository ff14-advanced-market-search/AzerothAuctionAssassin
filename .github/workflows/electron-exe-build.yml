name: Build EXE & DMG for Electron App

env:
  AAA_VERSION: "2.0.0"

on:
  workflow_dispatch:
  # push:

jobs:
  build-windows:
    runs-on: windows-latest
    outputs:
      upload_url_base64: ${{ steps.b64encode_upload_url.outputs.upload_url_base64 }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci || npm install

    - name: Decode Certificate
      run: |
        $cert_content = '${{ secrets.CERT_BASE64 }}'
        if ($cert_content -and $cert_content -ne '') {
          try {
            $cert_bytes = [Convert]::FromBase64String($cert_content)
            if ($cert_bytes.Length -eq 0) {
              Write-Error "Certificate decode resulted in empty byte array"
              exit 1
            }
            $cert_path = "certificate.pfx"
            [IO.File]::WriteAllBytes($cert_path, $cert_bytes)
            if (-not (Test-Path $cert_path)) {
              Write-Error "Failed to write certificate file"
              exit 1
            }
            echo "WIN_CERT_FILE=$cert_path" >> $env:GITHUB_ENV
            echo "WIN_CERT_PASSWORD=${{ secrets.CERT_PASSWORD }}" >> $env:GITHUB_ENV
          } catch {
            Write-Error "Failed to decode certificate: $_"
            exit 1
          }
        }
      shell: pwsh

    - name: Build Windows executable
      run: npm run build:win
      env:
        WIN_CERT_FILE: ${{ env.WIN_CERT_FILE }}
        WIN_CERT_PASSWORD: ${{ env.WIN_CERT_PASSWORD }}

    - name: Sign Windows Executable (if certificate available)
      env:
        CERT_PASSWORD: ${{ secrets.CERT_PASSWORD }}
      run: |
        if (Test-Path "certificate.pfx") {
          $cert_path = "certificate.pfx"
          $timestamp_url = "http://timestamp.digicert.com"
          
          # Resolve and validate signtool
          $signtoolPath = Resolve-Path "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" -ErrorAction SilentlyContinue | Select-Object -Last 1
          if (-not $signtoolPath -or -not (Test-Path $signtoolPath)) {
            Write-Error "signtool.exe not found. Please ensure Windows SDK is installed."
            exit 1
          }
          
          $executable_path = ".\dist-electron\Azeroth Auction Assassin Setup ${{ env.AAA_VERSION }}.exe"
          if (Test-Path $executable_path) {
            try {
              & $signtoolPath sign /f $cert_path /p $env:CERT_PASSWORD /tr $timestamp_url /td sha256 /fd sha256 /v $executable_path
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to sign installer: exit code $LASTEXITCODE"
                exit 1
              }
            } catch {
              Write-Error "Error signing installer: $_"
              exit 1
            }
          }
          # Also sign portable if it exists
          $portable_path = ".\dist-electron\Azeroth Auction Assassin-${{ env.AAA_VERSION }}-portable.exe"
          if (Test-Path $portable_path) {
            try {
              & $signtoolPath sign /f $cert_path /p $env:CERT_PASSWORD /tr $timestamp_url /td sha256 /fd sha256 /v $portable_path
              if ($LASTEXITCODE -ne 0) {
                Write-Error "Failed to sign portable: exit code $LASTEXITCODE"
                exit 1
              }
            } catch {
              Write-Error "Error signing portable: $_"
              exit 1
            }
          }
        }
      shell: pwsh

    - name: Create Release
      id: create_release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: "v${{env.AAA_VERSION}}"
        name: "Release v${{env.AAA_VERSION}}"
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Encode and Save Upload URL as Base64
      id: b64encode_upload_url
      run: |
        $uploadUrl = '${{ steps.create_release.outputs.upload_url }}'
        $bytes = [System.Text.Encoding]::UTF8.GetBytes($uploadUrl)
        $base64 = [Convert]::ToBase64String($bytes)
        echo "upload_url_base64=$base64" >> $env:GITHUB_OUTPUT
      shell: pwsh

    # - name: Upload Windows Installer to Release
    #   uses: actions/upload-release-asset@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     upload_url: ${{ steps.create_release.outputs.upload_url }}
    #     asset_path: .\dist-electron\Azeroth Auction Assassin Setup ${{ env.AAA_VERSION }}.exe
    #     asset_name: AzerothAuctionAssassin-Setup-${{ env.AAA_VERSION }}.exe
    #     asset_content_type: application/octet-stream
    #   if: ${{ always() }}

    - name: Upload Windows Portable to Release
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: .\dist-electron\Azeroth Auction Assassin-${{ env.AAA_VERSION }}-portable.exe
        asset_name: AzerothAuctionAssassin-${{ env.AAA_VERSION }}-portable.exe
        asset_content_type: application/octet-stream
      if: ${{ always() }}

  build-mac:
    needs: build-windows
    if: ${{ needs.build-windows.result == 'success' }}
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Decode Upload URL
      run: |
        if [ -z "${{ needs.build-windows.outputs.upload_url_base64 }}" ]; then
          echo "Error: upload_url_base64 is empty"
          exit 1
        fi
        echo "decoded_upload_url=$(echo '${{ needs.build-windows.outputs.upload_url_base64 }}' | base64 --decode)" >> $GITHUB_ENV

    - name: Install dependencies
      run: |
        npm ci || npm install

    - name: Decode Certificate
      run: |
        CERT_BASE64="${{ secrets.CERT_BASE64 }}"
        if [ -n "$CERT_BASE64" ]; then
          set -e
          echo "$CERT_BASE64" | base64 -d > certificate.pfx
          if [ ! -s certificate.pfx ]; then
            echo "Error: Certificate decode resulted in empty file"
            exit 1
          fi
          # Convert PFX to P12 for macOS if needed, or use directly
          # For self-signed certs, we'll try to import the PFX directly
          if ! security create-keychain -p "" build.keychain; then
            echo "Error: Failed to create keychain"
            exit 1
          fi
          if ! security default-keychain -s build.keychain; then
            echo "Error: Failed to set default keychain"
            exit 1
          fi
          if ! security unlock-keychain -p "" build.keychain; then
            echo "Error: Failed to unlock keychain"
            exit 1
          fi
          # Try importing as PFX first, if that fails, try converting
          if ! security import certificate.pfx -k build.keychain -P "${{ secrets.CERT_PASSWORD }}" -T /usr/bin/codesign -T /usr/bin/productsign; then
            echo "PFX import failed, attempting conversion to P12..."
            if ! openssl pkcs12 -in certificate.pfx -out certificate.p12 -nodes -passin pass:"${{ secrets.CERT_PASSWORD }}"; then
              echo "Error: Failed to convert PFX to P12"
              exit 1
            fi
            if ! security import certificate.p12 -k build.keychain -P "${{ secrets.CERT_PASSWORD }}" -T /usr/bin/codesign -T /usr/bin/productsign; then
              echo "Error: Failed to import P12 certificate"
              exit 1
            fi
          fi
          if ! security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain; then
            echo "Error: Failed to set key partition list"
            exit 1
          fi
        fi

    - name: Build macOS executable
      run: npm run build:mac

    - name: Sign macOS Executable (if certificate available)
      run: |
        if [ -f "certificate.pfx" ] || [ -f "certificate.p12" ]; then
          # Get the certificate identity name
          CERT_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID" | head -1 | sed 's/.*"\(.*\)".*/\1/' || \
                          security find-identity -v -p codesigning build.keychain | head -2 | tail -1 | sed 's/.*"\(.*\)".*/\1/')
          if [ -n "$CERT_IDENTITY" ]; then
            if ! codesign --deep --force --verify --verbose --sign "$CERT_IDENTITY" --keychain build.keychain --options runtime dist-electron/*.dmg; then
              echo "Error: Failed to sign DMG"
              exit 1
            fi
            if ! codesign --deep --force --verify --verbose --sign "$CERT_IDENTITY" --keychain build.keychain --options runtime dist-electron/*.zip; then
              echo "Error: Failed to sign ZIP"
              exit 1
            fi
          fi
        fi

    # put Decode Upload URL back here if it doesn't work up at the top

    - name: Upload macOS DMG to Release
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ env.decoded_upload_url }}
        asset_path: ./dist-electron/Azeroth Auction Assassin-${{ env.AAA_VERSION }}.dmg
        asset_name: AzerothAuctionAssassin-${{ env.AAA_VERSION }}-macOS.dmg
        asset_content_type: application/octet-stream
      if: ${{ always() && needs.build-windows.outputs.upload_url_base64 != '' }}

    # - name: Upload macOS ZIP to Release
    #   uses: actions/upload-release-asset@v1
    #   env:
    #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    #   with:
    #     upload_url: ${{ env.decoded_upload_url }}
    #     asset_path: ./dist-electron/Azeroth Auction Assassin-${{ env.AAA_VERSION }}-mac.zip
    #     asset_name: AzerothAuctionAssassin-${{ env.AAA_VERSION }}-macOS.zip
    #     asset_content_type: application/zip
    #   if: ${{ always() && needs.build-windows.outputs.upload_url_base64 != '' }}

